/**
 * The BMScrollView replaces standard scrolling to generate scroll events continuously for devices that don't support it.
 * The BMScrollView only supports touch scrolling.
 */
function BMScrollView() {}

BMScrollView.prototype = {
	/**
	 * The DOM element managed by this scroll view.
	 */
	_container: undefined, // <DOMElement>
	
	get container() { return this._container },
	set container(container) {
		if (this._container) {
			this._container.removeEventListener('scroll', this._containerScrollListener, YES);
			this._container.removeEventListener('touchstart', this._containerTouchStartListener, NO);		
			this._container.removeEventListener('touchmove', this._containerTouchMoveListener, YES);
			this._container.removeEventListener('touchmove', this._preventBounceMoveListener, NO);
			this._container.removeEventListener('touchend', this._containerTouchEndListener, YES);
		}
		
		this._container = container;
		
		container.addEventListener('scroll', this._containerScrollListener, YES);
		container.addEventListener('touchstart', this._containerTouchStartListener, NO);
		
		// Touch move and end event listeners use capture to prevent subviews from stealing events during an in-progress scroll
		container.addEventListener('touchmove', this._containerTouchMoveListener, YES);
		container.addEventListener('touchend', this._containerTouchEndListener, YES);
		
		container.addEventListener('touchmove', this._preventBounceMoveListener, NO);
		
		this._containerJQueryElement = $(container);
		
	},
	
	_content: undefined, // <DOMElement>
	
	/**
	 * The scroll offset.
	 */
	_offset: undefined, // <BMPoint>
	
	get offset() { return this._offset; },
	set offset(offset) {
		this._offset = offset.copy();
		
		this.scroll();
		
		this._content.style.transform = 'translate3d(' + (-this._offset.x) + 'px, ' + (-this._offset.y) + 'px, 0px)';
	},
	
	/**
	 * Assigns a new offset to this scroll view, causing the content to scroll to the specified point.
	 * @param offset <BMPoint>					The new scroll offset.
	 * {
	 *	@param animated <Boolean, nullable>		Defaults to NO. If set to YES, this change will be animated.
	 * }
	 */
	setOffset: function (offset, options) {
		this.offset = offset;
	},
	
	/**
	 * Should be set to YES if this scroller can scroll vertically.
	 */
	canScrollVertically: YES,
	
	/**
	 * Should be set to YES if this scroller can scroll horizontally.
	 */
	canScrollHorizontally: NO,
	
	/**
	 * Should only be invoked once during initialization.
	 */
	_init: function () {
		this._offset = new BMPoint();
		
		var self = this;
		
		this._containerScrollListener = this.containerDidScrollWithEvent.bind(this);
		this._containerTouchStartListener = this.containerTouchDidStartWithEvent.bind(this);
		
		var moveAnimationFrameRequested = NO;
		this._containerTouchMoveListener = function (event) {
			if (moveAnimationFrameRequested) {
				if (self.touchEventCaptured) {
					event.preventDefault();
					event.stopPropagation();
				}
				return;
			}
			
			moveAnimationFrameRequested = YES;
			window.requestAnimationFrame(function () {
				self.containerTouchDidMoveWithEvent(event);
				moveAnimationFrameRequested = NO;
			});
		}
		
		this._containerTouchEndListener = function (event) {
			window.requestAnimationFrame(function () {
				self.containerTouchDidEndWithEvent(event);
			});
		}
	},
	
	/**
	 * Stops all touch move events from reaching up to the document, which would normally cause the page to bounce
	 * preventing DOM manipulation during the overflow scrolling.
	 * @param event <Event>		The event triggered by the touch move.
	 */
	_preventBounceMoveListener: function (event) {
		event.preventDefault();
		event.stopPropagation();
	},
	
	/**
	 * Invoked whenever the container scrolls.
	 * @param event <Event>		The event that triggered this scroll.
	 */
	containerDidScrollWithEvent: function (event) {
		this._offset.x = this._container.scrollLeft;
		this._offset.y = this._container.scrollTop;
	},
	
	/**
	 * Set to YES for the duration of a touch gesture if a touch moves far enough to be considered a scroll.
	 */
	touchEventCaptured: NO,
	
	/**
	 * The number of pixels a touch has to move before it's considered a captured scroll event.
	 */
	touchEventCaptureThreshold: 5,
	
	/**
	 * Invoked whenever the user starts a touch gesture on the container.
	 * @param event <Event>		The event generated by this touch.
	 */
	containerTouchDidStartWithEvent: function (event) {
		if (!this._scrollingEnabled) return;
		
		// Ignore this event if already tracking a touch
		if (this.touchIdentifier) return;
		
		// Pause overflow scrolling if it was running
		if (this.overflowScrolling) this.stopOverflowScrolling();
		
		this.touchIdentifier = event.changedTouches[0].identifier;
		
		// Save the first touch positions
		this._lastX = event.changedTouches[0].screenX;
		this._lastY = event.changedTouches[0].screenY;
		
		this._initialX = event.changedTouches[0].screenX;
		this._initialY = event.changedTouches[0].screenY;
		
	},
	
	/**
	 * Invoked whenever a previously started touch gesture is moved.
	 * @param event <Event>		The event generated by this touch.
	 */
	containerTouchDidMoveWithEvent: function (event) {
		if (!this._scrollingEnabled) {
			alert('unable to move because scrolling is disabled');
			return;
		}
		
		var touch = event.touches[0];
		
		// Find the tracked touch

		var touch;
		for (var i = 0; i < event.changedTouches.length; i++) {
			if (event.changedTouches[i].identifier == this.touchIdentifier) {
				touch = event.changedTouches[i];
				break;
			}
		}
		
		// If it didn't change, don't do any processing
		if (!touch) return;
		
		var offset = this._offset;
		var canScrollHorizontally = this.canScrollHorizontally;
		var canScrollVertically = this.canScrollVertically;

		// Stop the event from reaching other objects if the touch event is captured
		if (this.touchEventCaptured) {
			event.preventDefault();
			event.stopPropagation();
		}
		else {
			// otherwise check to see if the touch event should be captured.
			var deltaX = canScrollHorizontally ? Math.abs(touch.screenX - this._initialX) : 0;
			var deltaY = canScrollVertically ? Math.abs(touch.screenY - this._initialY) : 0;
			
			if (deltaX > this.touchEventCaptureThreshold || deltaY > this.touchEventCaptureThreshold) {
				this.touchEventCaptured = YES;
			}
			
		}
		
		// Find the x and y deltas and scroll by that amount
		var dx = canScrollHorizontally ? touch.screenX - this._lastX : 0;
		var dy = canScrollVertically ? touch.screenY - this._lastY : 0;
		
		// Halve the displacement deltas if they go outside the bounds
		if (offset.x < 0 || offset.x > this.size.width - this.frame.size.width) dx = dx / 2;
		if (offset.y < 0 || offset.y > this.size.height - this.frame.size.height) dy = dy / 2;
		
		offset.x -= dx;
		offset.y -= dy;
		
		// Re-apply the new offset
		this.offset = offset;
		
		this._lastX = touch.screenX;
		this._lastY = touch.screenY;
		
		this._lastDX = dx;
		this._lastDY = dy;
		
	},
	
	/**
	 * Invoked whenever a previously started touch gesture ends.
	 * @param event <Event>		The event generated by this touch.
	 */
	containerTouchDidEndWithEvent: function (event) {
		if (!this._scrollingEnabled) return;

		// Find the tracked touch
		var touch;
		for (var i = 0; i < event.changedTouches.length; i++) {
			if (event.changedTouches[i].identifier == this.touchIdentifier) {
				touch = event.changedTouches[i];
				break;
			}
		}
		
		// If it didn't change, don't do any processing
		if (!touch) return;

		// Reset the touch identifier
		this.touchIdentifier = undefined;
		
		// Stop all other views from receiving this event
		event.preventDefault();
		event.stopPropagation();
		
		// If the user didn't move enough for this to be considered a scroll, don't do anything, unless the scroll was stopped while out of bounds
		if (!this.touchEventCaptured &&
			!((this._offset.x < 0 || this._offset.x > this.size.width - this.frame.size.width) || 
			 (this._offset.y < 0 || this._offset.y > this.size.height - this.frame.size.height))
			) return;
		
		// Reset the capture status
		this.touchEventCaptured = NO;
		
		// Increase the momentum for repeated swipes, but only if they are in the same direction
		if (Math.sign(this.accumulatedOverflowSpeedX) === Math.sign(this._lastDX)) {
			this.accumulatedOverflowSpeedX += this._lastDX;
		}
		else {
			this.accumulatedOverflowSpeedX = this._lastDX;
		}
		
		if (Math.sign(this.accumulatedOverflowSpeedY) === Math.sign(this._lastDY)) {
			this.accumulatedOverflowSpeedY += this._lastDY;
		}
		else {
			this.accumulatedOverflowSpeedY = this._lastDY;
		}
		
		// Fire the momentum scroll; clamp the scroll between the content's bounds
		var targetX = Math.min(Math.max(0, this._offset.x - 40 * this.accumulatedOverflowSpeedX), this.size.width - this.frame.size.width);
		var targetY = Math.min(Math.max(0, this._offset.y - 40 * this.accumulatedOverflowSpeedY), this.size.height - this.frame.size.height);
		
		var sourceX = this._offset.x;
		var sourceY = this._offset.y;
		
		var self = this;
		
		var initialAccumulatedOverflowSpeedX = this.accumulatedOverflowSpeedX;
		var initialAccumulatedOverflowSpeedY = this.accumulatedOverflowSpeedY;
		
		this.overflowScrolling = YES;
		this._containerJQueryElement.velocity({
			tween: [1, 0]
		}, {
			duration: 800,
			easing: 'easeOutCubic',
			progress: function (elements, complete, remaining, start, fraction) {
				// Compute the new scroll offset
				var x = (targetX - sourceX) * fraction + sourceX;
				var y = (targetY - sourceY) * fraction + sourceY;
				
				// Apply it - this triggers both the scroll listener and applies the correct transform
				self.offset = BMPointMake(x, y);
				
				// Decrease the active speed
				self.accumulatedOverflowSpeedX = (1 - fraction) * initialAccumulatedOverflowSpeedX;
				self.accumulatedOverflowSpeedY = (1 - fraction) * initialAccumulatedOverflowSpeedY;
			},
			complete: function () {
				self.overflowScrolling = NO;
				self.accumulatedOverflowSpeedX = 0;
				self.accumulatedOverflowSpeedY = 0;
			},
			queue: 'BMScrollViewQueue'
		});
		
		this._containerJQueryElement.dequeue('BMScrollViewQueue');
		
	},
	
	/**
	 * Immediately stops overflow scrolling.
	 */
	stopOverflowScrolling: function () {
		this._containerJQueryElement.velocity('stop', 'BMScrollViewQueue');
		this.overflowScrolling = NO;
	},
	
	/**
	 * Controls whether scrolling is enabled or not.
	 * If set to NO, while the user is scrolling or the scroll view is finishing a momentum scroll, that scroll will be stopped immediately.
	 */
	_scrollingEnabled: YES,
	
	get scrollingEnabled() { return this._scrollingEnabled; },
	set scrollingEnabled(enabled) {
		this._scrollingEnabled = enabled;
		
		if (!enabled) {
			// Terminate overflow scrolling
			if (this.overflowScrolling) {
				this._containerJQueryElement.velocity('stop', 'BMScrollViewQueue');
				this.overflowScrolling = NO;
				this.accumulatedOverflowSpeedX = 0;
				this.accumulatedOverflowSpeedY = 0;
			}
			
			// Terminate touch events
			this.touchEventCaptured = NO;
			this.touchIdentifier = undefined;
		}	
	}
	
	
};

/**
 * Constructs and returns a new BMScrollView for the given container.
 * @param container <DOMElement>		The container that should be managed by this scroll view
 * {
 *	@param size <BMSize>				The scrollable content's size.
 * 	@param frame <BMRect>				The scrollable container's frame.
 *  @param content <DOMElement>			The content that this scroll view should scroll.
 *  @param scrollCallback <void ^ ()>	The callback invoked whenever this scroll view scrolls.
 * }
 */
function BMScrollViewMakeWithContainer(container, options) {
	var scrollView = new BMScrollView();
	
	scrollView._init();
	scrollView.container = container;
	scrollView.size = options.size;
	scrollView.frame = options.frame;
	scrollView._content = options.content;
	scrollView.scroll = options.scrollCallback;
	
	return scrollView;
}